[
  {
    "id": "1",
    "slug": "blazor-nedir-spa-karsilastirmasi",
    "title": "Blazor Nedir? Diğer SPA Framework’lerle Karşılaştırma",
    "summary": "Blazor WebAssembly nedir, ne zaman çıktı, hangi ihtiyaçlara hitap eder?",
    "description": "Blazor ile Angular, React gibi framework’ler arasında farklar neler? Avantajlar ve sınırlamalar.",
    "coverImage": "img/blog/blog1.webp",
    "date": "2025-07-24",
    "content": "<h2 style=\"margin-top: 1rem;\">Blazor Nedir?</h2>\n<p>Blazor, Microsoft tarafından geliştirilen ve .NET platformu üzerinde çalışan bir web uygulama framework’üdür. 2018 yılında ilk kez tanıtılmış, Blazor Server sürümü .NET Core 3.0 (Eylül 2019) ile resmi olarak kullanıma sunulmuştur. Blazor WebAssembly (Blazor WASM) ise Mayıs 2020’de .NET 5 öncesi bağımsız bir versiyon olarak kararlı sürüme ulaşmıştır.</p>\n<p>Blazor’un temel amacı, C# geliştiricilerine client-side (istemci taraflı) uygulamalar geliştirme imkânı sağlamaktır. Bu sayede JavaScript’e gerek kalmadan, tarayıcı üzerinde C# ile çalışan Single Page Application (SPA) projeleri geliştirilebilir.</p>\n\n<h3 style=\"margin-top: 1.5rem;\">Blazor Türleri</h3>\n<ul style=\"padding-left: 1.2rem;\">\n  <li><strong>Blazor Server</strong>: Uygulama mantığı sunucuda çalışır. SignalR ile tarayıcıya UI güncellemeleri gönderilir.</li>\n  <li><strong>Blazor WebAssembly (WASM)</strong>: Uygulama tamamen tarayıcıda çalışır. C# kodu WebAssembly ortamında yürütülür.</li>\n</ul>\n\n<h3 style=\"margin-top: 1.5rem;\">Blazor ve Diğer SPA Framework’leri Arasındaki Temel Farklar</h3>\n<div style=\"overflow-x: auto;\">\n  <table style=\"border-collapse: collapse; width: 100%; font-size: 0.95rem;\">\n    <thead>\n      <tr style=\"background-color: #f2f2f2;\">\n        <th style=\"padding: 8px; border: 1px solid #ccc;\">Özellik</th>\n        <th style=\"padding: 8px; border: 1px solid #ccc;\">Blazor WASM</th>\n        <th style=\"padding: 8px; border: 1px solid #ccc;\">React / Angular / Vue</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">Geliştirme Dili</td>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">C#</td>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">JavaScript / TypeScript</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">Çalışma Ortamı</td>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">WebAssembly</td>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">JavaScript Engine</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">Başlangıç Performansı</td>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">Görece yavaş (ilk yükleme)</td>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">Genellikle hızlı</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">SEO Uyumlu</td>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">Sınırlı (WASM)</td>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">SSR ile mümkün</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">Ekosistem / Topluluk</td>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">Yükselmekte</td>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">Oturmuş</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">Microsoft Desteği</td>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">Resmi destekli</td>\n        <td style=\"padding: 8px; border: 1px solid #ccc;\">Topluluk bazlı</td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n\n<h3 style=\"margin-top: 1.5rem;\">Avantajları</h3>\n<ul style=\"padding-left: 1.2rem;\">\n  <li>C# bilgisi olan geliştiriciler için öğrenme eğrisi düşüktür.</li>\n  <li>Tam .NET desteği sayesinde backend ve frontend aynı dilde yazılabilir.</li>\n  <li>Component tabanlı mimari.</li>\n  <li>Modern tooling: Dependency injection, routing, event binding vb.</li>\n</ul>\n\n<h3 style=\"margin-top: 1.5rem;\">Dezavantajları</h3>\n<ul style=\"padding-left: 1.2rem;\">\n  <li>İlk yükleme boyutu Blazor WASM için yüksektir (2-4 MB civarı olabilir).</li>\n  <li>Üçüncü parti UI kütüphaneleri hâlâ sınırlıdır.</li>\n  <li>SEO ve SSR (server-side rendering) desteği sınırlıdır. ASP.NET Core + prerendering çözümleri mevcuttur ama karmaşık olabilir.</li>\n</ul>\n\n<h3 style=\"margin-top: 1.5rem;\">Sonuç</h3>\n<p>Blazor, .NET geliştiricileri için güçlü ve tutarlı bir SPA çözümüdür. JavaScript'e ihtiyaç duymadan web uygulamaları geliştirmek isteyenler için cazip bir seçenektir. Ancak SEO, performans ve ekosistem boyutları hâlâ gelişim aşamasındadır. Kurumsal projelerde Blazor Server tercih edilirken, statik ya da intranet uygulamaları için Blazor WASM daha uygundur.</p><div style=\"height: 80px;\"></div>"
  },
  {
    "id": "2",
    "slug": "jwt-nedir-dotnet-ile-kullanim",
    "title": "JWT Nedir? .NET ile Kullanımı, Alternatifler ve Güvenlik İpuçları",
    "summary": "JWT (JSON Web Token) tabanlı kimlik doğrulamanın temelleri, .NET Web API ile uygulama rehberi, alternatif yöntemlerle karşılaştırmalar ve güvenlik detayları.",
    "description": "Modern web uygulamalarında kimlik doğrulama için yaygın olarak kullanılan JWT (JSON Web Token) sistemi, .NET ekosisteminde nasıl uygulanır ve hangi durumlarda uygundur?",
    "coverImage": "img/blog/blog2.webp",
    "date": "2025-07-25",
    "content": "JWT (JSON Web Token), iki taraf arasında güvenli bilgi iletimi için kullanılan, standartlara uygun (RFC 7519) ve dijital olarak imzalanmış bir token yapısıdır. Özellikle RESTful mimarilerde kimlik doğrulama (authentication) ve yetkilendirme (authorization) işlemlerinde yaygın olarak kullanılır.<br><br><strong>JWT Nasıl Çalışır?</strong><br>JWT, genellikle kullanıcı adı ve şifre doğrulandıktan sonra sunucu tarafından oluşturulur ve istemciye gönderilir. İstemci bu token’ı her istekte <code>Authorization: Bearer &lt;token&gt;</code> başlığıyla gönderir. Token içinde kullanıcı bilgileri (örneğin ID, e-posta, roller vs.) payload kısmında saklanır.<br><br>Bir JWT üç parçadan oluşur:<br>1. <strong>Header</strong>: Token tipi (typ: JWT) ve imzalama algoritması (örneğin HS256)<br>2. <strong>Payload</strong>: Kullanıcı bilgileri (claims)<br>3. <strong>Signature</strong>: İmza (secret key ile oluşturulur)<br><br><strong>.NET ile JWT Kullanımı</strong><br>ASP.NET Core ortamında JWT doğrulaması için <code>Microsoft.AspNetCore.Authentication.JwtBearer</code> paketi kullanılır. <code>Startup.cs</code> veya <code>Program.cs</code> içerisinde <code>JwtBearerDefaults.AuthenticationScheme</code> ile middleware tanımlanır.<br><br><strong>Alternatif Kimlik Doğrulama Yöntemleri</strong><br>JWT dışında yaygın kullanılan diğer kimlik doğrulama yöntemleri:<br>- <strong>Session Tabanlı Kimlik Doğrulama</strong>: Kullanıcının bilgisi sunucuda oturumda tutulur. Geleneksel web uygulamaları için uygundur. Scale etmek zordur.<br>- <strong>OAuth 2.0</strong>: Genellikle sosyal medya (Google, Facebook) gibi üçüncü parti kimlik sağlayıcılar ile kullanılır. Delegated access sağlar.<br>- <strong>OpenID Connect (OIDC)</strong>: OAuth 2.0 üzerine inşa edilmiştir. Kimlik doğrulama için standart protokoldür.<br>- <strong>Cookie Authentication</strong>: Kullanıcının tarayıcısına cookie yerleştirilir. CSRF riskine karşı ek önlemler gerekir.<br><br><strong>JWT ile farkları:</strong><br>- JWT <strong>stateless</strong> bir yapıya sahiptir (sunucu tarafında oturum tutulmaz).<br>- Dağıtık sistemlerde (microservices gibi) daha uygundur.<br>- Tarayıcı dışı ortamlarda (mobil, IoT) rahatça kullanılabilir.<br><br><strong>Güvenlikte Dikkat Edilmesi Gerekenler</strong><br>- <strong>Token Saklama</strong>: Tarayıcıda <code>localStorage</code> yerine mümkünse <code>HttpOnly</code> cookie kullanımı tercih edilmelidir.<br>- <strong>Signature Güvenliği</strong>: Güçlü ve gizli bir <code>secret key</code> kullanın. Asla source kontrol sistemlerinde paylaşmayın.<br>- <strong>Token Süresi (exp claim)</strong>: Token süresi kısa tutulmalı, uzun oturumlar için refresh token sistemi uygulanmalıdır.<br>- <strong>Algoritma Sabitleme</strong>: Sadece HS256 gibi bilinen algoritmaları kabul edin. <code>alg=none</code> gibi boş değerlerin kabul edilmesi ciddi güvenlik açığıdır.<br>- <strong>Blacklisting / Revocation</strong>: JWT tokenlar stateless olduğu için silinemez. Bu nedenle refresh token sistemi veya revocation mekanizması gerekir.<br><br><strong>Hangi Projelerde Kullanılır?</strong><br>JWT özellikle:<br>- SPA frontend (React, Angular, Blazor WASM)<br>- Mobil uygulamalar (Xamarin, React Native)<br>- Microservice-based backend sistemlerde<br>- API-first mimarilerde tercih edilir.<br><br>Ancak klasik web uygulamalarında (örneğin Razor Pages + server-side rendering) cookie tabanlı auth hâlâ daha pratiktir.<br><br><strong>Sonuç</strong><br>JWT, modern uygulamalar için güçlü ve esnek bir kimlik doğrulama yöntemidir. Ancak kullanım kolaylığı, güvenlikten ödün verilerek sağlanmamalıdır. Token yaşam döngüsü, saklama yöntemleri ve refresh mekanizmaları iyi tasarlanmalıdır. .NET geliştiricileri için JWT ile kimlik doğrulama, geniş kütüphane desteği sayesinde kolayca uygulanabilir.<div style='height: 80px;'></div>"
  },
  {
    "id": "3",
    "slug": "clean-architecture-dotnet",
    "title": "Clean Architecture Nedir? .NET Projelerinde Kullanımı ve Diğer Mimarilerle Karşılaştırma",
    "summary": "Clean Architecture’ın temel prensipleri, .NET projelerinde uygulama rehberi ve N-Tier ile Onion Architecture farkları.",
    "description": "Clean Architecture nedir? Katmanlı mimarilere göre avantajları nelerdir? .NET geliştiricileri için gerçek dünya senaryolarıyla açıklıyoruz.",
    "coverImage": "img/blog/blog3.webp",
    "date": "2025-07-26",
    "content": "Clean Architecture, yazılım sistemlerinde yüksek sürdürülebilirlik, test edilebilirlik ve bağımlılık kontrolü sağlamak amacıyla Robert C. Martin (Uncle Bob) tarafından önerilen bir mimari modeldir. Temel amacı, uygulama iş mantığını dış dünyadan (UI, veri erişimi, frameworkler vs.) izole etmektir.<br><br><strong>Clean Architecture’ın Katmanları</strong><br>1. <strong>Entities</strong>: İş kurallarını temsil eden saf C# sınıfları (domain modelleri).<br>2. <strong>Use Cases / Application</strong>: İş akışlarının tanımlandığı katman. Entity'lerle çalışır.<br>3. <strong>Interface Adapters</strong>: Controller’lar, ViewModel’ler, DTO dönüşümleri.<br>4. <strong>Frameworks & Drivers</strong>: ASP.NET, EF Core, dış servisler, UI framework’leri vs.<br><br>Yönlendirilmiş bağımlılık prensibine göre, <strong>bağımlılıklar hep dıştan içe doğrudur.</strong> Yani core katmanlar (domain, application) dış katmanlara bağımlı olamaz.<br><br><strong>Clean Architecture vs. N-Tier Architecture</strong><br><table class='table table-striped'><thead><tr><th>Özellik</th><th>Clean Architecture</th><th>N-Tier Architecture</th></tr></thead><tbody><tr><td>Katmanlar arası bağımlılık</td><td>Dıştan içe (Dependency Inversion)</td><td>Yukarıdan aşağıya</td></tr><tr><td>Test Edilebilirlik</td><td>Yüksek</td><td>Düşük</td></tr><tr><td>Domain odaklılık</td><td>Evet</td><td>Genellikle yok</td></tr><tr><td>Use-case yapısı</td><td>Ayrı ve belirgin</td><td>Genelde Service katmanında</td></tr><tr><td>Bağımlılık kontrolü</td><td>Katı (örnek: Application EF'yi bilmez)</td><td>Gevşek / ihlal edilebilir</td></tr></tbody></table><br><strong>N-Tier</strong>, geleneksel olarak Presentation, Business, Data Access gibi katmanlardan oluşur. Ancak çoğu zaman katmanlar arası sınırlar bulanıktır. Application katmanı Entity Framework'e doğrudan bağımlı olabilir, bu da test edilebilirliği azaltır.<br><br><strong>Clean Architecture vs. Onion Architecture</strong><br><table class='table table-striped'><thead><tr><th>Özellik</th><th>Clean Architecture</th><th>Onion Architecture</th></tr></thead><tbody><tr><td>Kavramsal yapı</td><td>Layered + Hexagonal</td><td>Layered (soğan katmanı gibi)</td></tr><tr><td>UI bağımlılığı</td><td>En dışta</td><td>En dışta</td></tr><tr><td>Entity merkeziyet</td><td>Var</td><td>Var</td></tr><tr><td>Uygulama servisleri</td><td>Use Case şeklinde ayrılır</td><td>Service sınıfları içinde</td></tr><tr><td>Esneklik</td><td>Daha soyut, plugin yapısı desteklenebilir</td><td>Katı ama net ayrım</td></tr></tbody></table><br>Onion mimarisi de domain merkezlidir ama Clean Architecture kadar \"plugin\" mimarisi desteklemez. Clean Architecture daha soyut ve senaryoya göre farklı katman kombinasyonlarına izin verebilir.<br><br><strong>Clean Architecture .NET'te Nasıl Uygulanır?</strong><br>- <strong>Domain</strong> katmanında yalnızca <code>Entity</code>, <code>ValueObject</code>, <code>Enum</code>, <code>Interface</code> tanımlanır. EF Core, hiçbir şekilde burada kullanılmaz.<br>- <strong>Application</strong> katmanı CQRS ve MediatR ile organize edilir (Command, Query, Handler).<br>- <strong>Infrastructure</strong> katmanında EF Core, dış servisler (Mail, Token), dosya işlemleri vs. yer alır.<br>- <strong>WebAPI</strong> giriş noktasıdır. Controller’lar Application ile sadece interface’ler üzerinden haberleşir.<br><br><strong>Ne Zaman Kullanılmalı?</strong><br>Clean Architecture;<br>- Orta ve büyük ölçekli projelerde,<br>- Test edilebilirlik ve sürdürülebilirliğin öncelikli olduğu yapılarda,<br>- Birden fazla istemcinin aynı backend’i kullanacağı sistemlerde (mobil + web)<br>kullanılması önerilir.<br><br><strong>Dezavantajları</strong><br>- Başlangıçta kurulum karmaşık gelebilir.<br>- Küçük projeler için fazla soyutlama barındırabilir.<br>- Tecrübeli ekipler gerektirir.<br><br><strong>Sonuç</strong><br>Clean Architecture, .NET projelerinde bağımlılık yönetimi, test edilebilirlik ve sürdürülebilirlik açısından en güçlü mimari yaklaşımlardan biridir. N-Tier gibi geleneksel mimarilerin zayıf yönlerini giderirken, Onion mimariden daha esnek ve uygulamaya dönük çözümler sunar. Doğru uygulandığında, uzun ömürlü ve sağlam bir yazılım temeli sağlar.<div style='height: 80px;'></div>"
  },
  {
    "id": "4",
    "slug": "mediatr-ucretli-oldu-jimmy-bogard-karari",
    "title": "MediatR Ücretli Oldu: Jimmy Bogard’ın Kararı, Gerekçeleri ve Alternatifler",
    "summary": "MediatR artık açık kaynaklı değil mi? Jimmy Bogard neden böyle bir karar aldı? Geliştiriciler ne yapmalı? Tüm detaylar bu yazıda.",
    "description": "MediatR kütüphanesi 2025 itibarıyla ticari lisansa geçti. Bu yazıda hem kararın nedenlerini hem de geliştiriciler için sonuçlarını inceliyoruz.",
    "coverImage": "img/blog/blog4.webp",
    "date": "2025-07-27",
    "content": "MediatR, .NET ekosisteminde Clean Architecture, CQRS ve Vertical Slice gibi yapılara adım atan herkesin mutlaka karşılaştığı bir kütüphane. Ancak 2025 Nisan ayında, bu popüler kütüphaneyle ilgili önemli bir gelişme yaşandı: Yaratıcısı Jimmy Bogard, MediatR'ı artık ticari lisansla yayınlayacağını duyurdu.<br><br><strong>Neler Oldu?</strong><br>Jimmy Bogard, resmi blog yazısında hem MediatR hem de AutoMapper projelerinin yeni sürümlerinin açık kaynak olmayacağını, bunun yerine ticari ve topluluk (community) lisanslarıyla dağıtılacağını açıkladı. Önceki sürümler MIT lisanslı olarak kullanılabilir durumda kalmaya devam edecek, ancak yeni özellikler sadece yeni lisans modeliyle gelen sürümlerde yer alacak.<br><blockquote>“Yıllar boyunca AutoMapper ve MediatR açık kaynak olarak kullanıma açıktı. Ancak bunların geliştirilmesi ve bakımını sağlamak hiç kolay değildi.” — Jimmy Bogard</blockquote><br><strong>Neden Bu Karar Alındı?</strong><br>Jimmy Bogard uzun süre Headspring şirketinde çalışırken bu projelere zaman ayırabiliyordu. Ancak şirketten ayrıldıktan sonra sponsorluklar azaldı, GitHub destekleri yeterli olmadı. Açık kaynak dünyasında sürdürülebilirlik her zaman bir tartışma konusuydu. Jimmy bunu açıkça dile getirdi:<br><blockquote>“GitHub sponsorluğu veya şirket katkısı olmadan bu projelere haftada 20 saat ayırmam mümkün değil.”</blockquote><br><strong>Yeni Lisans Modeli</strong><br>Yeni sürümler (MediatR v13 ve sonrası), dual-license modeliyle sunuluyor:<ul><li><strong>RPL 1.5 (Reciprocal Public License)</strong>: Açık kaynak ama bazı sınırlamalar içeriyor.</li><li><strong>Ticari Lisans</strong>: Kurumsal projeler için geliştirici sayısına göre ücretlendiriliyor.</li></ul>Buna ek olarak bireysel geliştiriciler, açık kaynak projeler, eğitim ve kâr amacı gütmeyen kurumlar için <strong>community edition</strong> ücretsiz olarak kullanılabiliyor.<br><br><strong>Topluluk Tepkisi</strong><br>Geliştirici topluluğu genel olarak bu kararı anlayışla karşıladı. MediatR gibi yıllarca ücretsiz sunulan bir projeye karşılık vermek gerektiği düşünülüyor. Ancak bazı ekipler alternatif arayışlarına yöneldi. Özellikle yüksek lisans maliyetinden kaçınmak isteyen küçük ölçekli projeler için hafif çözümler önerilmeye başlandı.<br><br><strong>Alternatifler</strong><br><ul><li><strong>Mediator</strong>: Source generator tabanlı, hafif ve performanslı bir alternatif.</li><li><strong>Brighter</strong>: CQRS ve messaging üzerine geliştirilmiş bir başka güçlü seçenek.</li><li><strong>Kendi MediatR benzeri sisteminizi yazmak</strong>: Özellikle basit uygulamalarda mümkün.</li></ul><br><strong>MediatR’ın Önemi</strong><br>MediatR, .NET dünyasında özellikle şu alanlarda yaygın olarak kullanılmaktadır:<ul><li>CQRS (Command Query Responsibility Segregation)</li><li>Clean Architecture</li><li>Vertical Slice mimarileri</li><li>Pipeline behaviors ile loglama, validation ve cache yönetimi</li></ul>Komut ve sorguların birbirinden ayrılması, uygulamaların test edilebilirliğini artırır ve kodun sorumluluklarını netleştirir. MediatR, bu ayrımı minimum kodla ve oldukça sade bir şekilde sağlar.<br><br><strong>Sonuç</strong><br>MediatR artık ücretsiz değil, ancak yıllar boyunca sağladığı katkılar düşünüldüğünde, bu bir değer dönüşümüdür. Açık kaynak geliştiricilerin sürdürülebilirlik için farklı yollara yönelmesi kaçınılmaz. Yeni lisans modeli ile hem bireysel geliştiriciler hem de şirketler için farklı seçenekler sunulmuş durumda. Geliştiriciler artık ihtiyaçlarına ve bütçelerine göre MediatR'ı mı kullanacaklarına, yoksa alternatiflere mi yöneleceklerine karar verecekler.<div style='height: 80px;'></div>"
  }
]
