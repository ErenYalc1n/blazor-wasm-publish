[
  {
    "id": "1",
    "slug": "what-is-blazor-spa-comparison",
    "title": "What Is Blazor? Comparison with Other SPA Frameworks",
    "summary": "What is Blazor WebAssembly, when was it released, and what needs does it address?",
    "description": "How does Blazor differ from frameworks like Angular and React? A look into its advantages and limitations.",
    "coverImage": "img/blog/blog1.webp",
    "date": "2025-07-24",
    "content": "<h2 style=\"margin-top: 1rem;\">What is Blazor?</h2><p>Blazor is a web application framework developed by Microsoft that runs on the .NET platform. It was first introduced in 2018, and the Blazor Server version was officially released with .NET Core 3.0 in September 2019. Blazor WebAssembly (Blazor WASM) reached its stable release in May 2020, just before .NET 5.</p><p>Blazor’s main goal is to enable C# developers to build client-side applications using C#, without needing JavaScript. This allows Single Page Applications (SPAs) to run entirely in the browser using WebAssembly.</p><h3 style=\"margin-top: 1.5rem;\">Types of Blazor</h3><ul style=\"padding-left: 1.2rem;\"><li><strong>Blazor Server</strong>: Application logic runs on the server. UI updates are pushed to the browser via SignalR.</li><li><strong>Blazor WebAssembly (WASM)</strong>: The entire application runs in the browser. C# code executes within the WebAssembly environment.</li></ul><h3 style=\"margin-top: 1.5rem;\">Key Differences Between Blazor and Other SPA Frameworks</h3><div style=\"overflow-x: auto;\"><table style=\"border-collapse: collapse; width: 100%; font-size: 0.95rem;\"><thead><tr style=\"background-color: #f2f2f2;\"><th style=\"padding: 8px; border: 1px solid #ccc;\">Feature</th><th style=\"padding: 8px; border: 1px solid #ccc;\">Blazor WASM</th><th style=\"padding: 8px; border: 1px solid #ccc;\">React / Angular / Vue</th></tr></thead><tbody><tr><td style=\"padding: 8px; border: 1px solid #ccc;\">Programming Language</td><td style=\"padding: 8px; border: 1px solid #ccc;\">C#</td><td style=\"padding: 8px; border: 1px solid #ccc;\">JavaScript / TypeScript</td></tr><tr><td style=\"padding: 8px; border: 1px solid #ccc;\">Runtime Environment</td><td style=\"padding: 8px; border: 1px solid #ccc;\">WebAssembly</td><td style=\"padding: 8px; border: 1px solid #ccc;\">JavaScript Engine</td></tr><tr><td style=\"padding: 8px; border: 1px solid #ccc;\">Initial Load Performance</td><td style=\"padding: 8px; border: 1px solid #ccc;\">Relatively slow (initial load)</td><td style=\"padding: 8px; border: 1px solid #ccc;\">Generally fast</td></tr><tr><td style=\"padding: 8px; border: 1px solid #ccc;\">SEO Friendly</td><td style=\"padding: 8px; border: 1px solid #ccc;\">Limited (WASM)</td><td style=\"padding: 8px; border: 1px solid #ccc;\">Possible with SSR</td></tr><tr><td style=\"padding: 8px; border: 1px solid #ccc;\">Ecosystem / Community</td><td style=\"padding: 8px; border: 1px solid #ccc;\">Growing</td><td style=\"padding: 8px; border: 1px solid #ccc;\">Mature</td></tr><tr><td style=\"padding: 8px; border: 1px solid #ccc;\">Microsoft Support</td><td style=\"padding: 8px; border: 1px solid #ccc;\">Officially supported</td><td style=\"padding: 8px; border: 1px solid #ccc;\">Community-driven</td></tr></tbody></table></div><h3 style=\"margin-top: 1.5rem;\">Advantages</h3><ul style=\"padding-left: 1.2rem;\"><li>Low learning curve for developers familiar with C#.</li><li>Full .NET support allows backend and frontend to use the same language.</li><li>Component-based architecture.</li><li>Modern tooling: dependency injection, routing, event binding, etc.</li></ul><h3 style=\"margin-top: 1.5rem;\">Disadvantages</h3><ul style=\"padding-left: 1.2rem;\"><li>Initial load size for Blazor WASM is relatively large (around 2–4 MB).</li><li>Third-party UI libraries are still limited.</li><li>SEO and server-side rendering (SSR) support is limited. ASP.NET Core + prerendering is available but can be complex.</li></ul><h3 style=\"margin-top: 1.5rem;\">Conclusion</h3><p>Blazor is a powerful and consistent SPA solution for .NET developers. It's a compelling option for building web apps without relying on JavaScript. However, aspects such as SEO, performance, and ecosystem maturity are still evolving. For enterprise applications, Blazor Server is often preferred, while Blazor WASM is well-suited for static sites or intranet solutions.</p><div style=\"height: 80px;\"></div>"
  },
  {
    "id": "2",
    "slug": "what-is-jwt-dotnet-usage",
    "title": "What is JWT? Usage with .NET, Alternatives, and Security Tips",
    "summary": "Foundations of JWT-based authentication, a .NET Web API implementation guide, comparisons with alternatives, and security considerations.",
    "description": "How the widely-used JWT (JSON Web Token) authentication system is implemented in the .NET ecosystem, and when it is appropriate to use.",
    "coverImage": "img/blog/blog2.webp",
    "date": "2025-07-25",
    "content": "JWT (JSON Web Token) is a digitally signed token structure, compliant with the RFC 7519 standard, used for securely transmitting information between two parties. It is widely adopted in RESTful architectures for authentication and authorization processes.<br><br><strong>How JWT Works</strong><br>A JWT is typically created by the server after validating a username and password, and then sent to the client. The client includes this token in every request using the <code>Authorization: Bearer &lt;token&gt;</code> header. User information (e.g., ID, email, roles, etc.) is stored in the payload section of the token.<br><br>A JWT consists of three parts:<ol><li><strong>Header</strong>: Specifies the token type (typ: JWT) and the signing algorithm (e.g., HS256)</li><li><strong>Payload</strong>: Contains the claims or user data</li><li><strong>Signature</strong>: The digital signature generated using a secret key</li></ol><br><strong>Using JWT in .NET</strong><br>In ASP.NET Core, JWT authentication is handled using the <code>Microsoft.AspNetCore.Authentication.JwtBearer</code> package. Middleware is configured with <code>JwtBearerDefaults.AuthenticationScheme</code> in <code>Startup.cs</code> or <code>Program.cs</code>.<br><br><strong>Alternative Authentication Methods</strong><br>Besides JWT, other common authentication methods include:<ul><li><strong>Session-Based Authentication</strong>: Stores user information on the server in a session. Suitable for traditional web apps but difficult to scale.</li><li><strong>OAuth 2.0</strong>: Often used with third-party providers like Google or Facebook to enable delegated access.</li><li><strong>OpenID Connect (OIDC)</strong>: Built on top of OAuth 2.0, it is the standard protocol for authentication.</li><li><strong>Cookie Authentication</strong>: Relies on browser cookies. Requires extra protection against CSRF attacks.</li></ul><br>Key differences with JWT:<ul><li>JWT is <strong>stateless</strong> (no server-side session storage).</li><li>More suitable for distributed systems (e.g., microservices).</li><li>Easily usable in non-browser environments (e.g., mobile apps, IoT).</li></ul><br><strong>Security Considerations</strong><ul><li><strong>Token Storage</strong>: Prefer <code>HttpOnly</code> cookies over <code>localStorage</code> to reduce XSS attack risks.</li><li><strong>Signature Security</strong>: Use a strong, secret key. Never expose it in version control.</li><li><strong>Token Expiry (exp claim)</strong>: Use short expiration times and implement a refresh token system for long sessions.</li><li><strong>Algorithm Enforcement</strong>: Accept only secure algorithms like HS256. Avoid allowing <code>alg=none</code>, which poses a severe vulnerability.</li><li><strong>Blacklisting / Revocation</strong>: Since JWTs are stateless, they cannot be revoked directly. Use refresh token mechanisms or external blacklists.</li></ul><br><strong>Where to Use JWT</strong><br>JWT is particularly suited for:<ul><li>SPA frontends (React, Angular, Blazor WASM)</li><li>Mobile apps (Xamarin, React Native)</li><li>Microservice-based backend systems</li><li>API-first architectures</li></ul><br>However, for traditional web applications (e.g., Razor Pages + server-side rendering), cookie-based authentication may still be more practical.<br><br><strong>Conclusion</strong><br>JWT is a powerful and flexible authentication method for modern applications. However, ease of use should not come at the expense of security. The token lifecycle, storage strategy, and refresh mechanisms must be carefully designed. Thanks to strong library support, JWT can be easily implemented in .NET applications.<div style='height: 80px;'></div>"
  },
  {
    "id": "3",
    "slug": "clean-architecture-dotnet",
    "title": "What is Clean Architecture? Usage in .NET Projects and Comparison with Other Architectures",
    "summary": "Fundamentals of Clean Architecture, implementation guide in .NET projects, and differences compared to N-Tier and Onion Architecture.",
    "description": "What is Clean Architecture? What are its advantages over layered architectures? Explained with real-world examples for .NET developers.",
    "coverImage": "img/blog/blog3.webp",
    "date": "2025-07-26",
    "content": "Clean Architecture is a software architecture model proposed by Robert C. Martin (Uncle Bob) to ensure maintainability, testability, and proper dependency control. Its main goal is to isolate the application’s business logic from external concerns like UI, data access, or frameworks.<br><br><strong>Layers of Clean Architecture</strong><br>1. <strong>Entities</strong>: Pure C# classes representing core business rules (domain models).<br>2. <strong>Use Cases / Application</strong>: Defines the application workflows. Works directly with entities.<br>3. <strong>Interface Adapters</strong>: Controllers, ViewModels, DTO mappings.<br>4. <strong>Frameworks & Drivers</strong>: ASP.NET, EF Core, external services, UI libraries, etc.<br><br>According to the dependency rule, <strong>all dependencies must point inward</strong>. In other words, core layers (Domain, Application) must not depend on the outer layers.<br><br><strong>Clean Architecture vs. N-Tier Architecture</strong><br><table class='table table-striped'><thead><tr><th>Feature</th><th>Clean Architecture</th><th>N-Tier Architecture</th></tr></thead><tbody><tr><td>Layer Dependency</td><td>Inward (Dependency Inversion)</td><td>Top-down</td></tr><tr><td>Testability</td><td>High</td><td>Low</td></tr><tr><td>Domain-Centric</td><td>Yes</td><td>Not typically</td></tr><tr><td>Use Case Structure</td><td>Well-defined</td><td>Usually in service layer</td></tr><tr><td>Dependency Control</td><td>Strict (e.g., Application doesn't reference EF)</td><td>Loose, often violated</td></tr></tbody></table><br><strong>N-Tier</strong> typically includes Presentation, Business, and Data Access layers, but the separation often gets blurred. For example, the Application layer might directly depend on EF Core, which reduces testability.<br><br><strong>Clean Architecture vs. Onion Architecture</strong><br><table class='table table-striped'><thead><tr><th>Feature</th><th>Clean Architecture</th><th>Onion Architecture</th></tr></thead><tbody><tr><td>Conceptual Structure</td><td>Layered + Hexagonal</td><td>Layered (like an onion)</td></tr><tr><td>UI Dependency</td><td>Outermost layer</td><td>Outermost layer</td></tr><tr><td>Entity Focus</td><td>Yes</td><td>Yes</td></tr><tr><td>Application Services</td><td>Use Case–based</td><td>Inside service classes</td></tr><tr><td>Flexibility</td><td>More abstract, plugin-ready</td><td>Strict but clear boundaries</td></tr></tbody></table><br>While both are domain-centric, Clean Architecture allows more flexibility and modular design compared to Onion Architecture.<br><br><strong>How to Apply Clean Architecture in .NET</strong><br>- <strong>Domain</strong> layer includes only <code>Entity</code>, <code>ValueObject</code>, <code>Enum</code>, and <code>Interface</code>. EF Core is excluded.<br>- <strong>Application</strong> layer uses CQRS with MediatR (Command, Query, Handler).<br>- <strong>Infrastructure</strong> handles EF Core, external services (Mail, Token), file I/O, etc.<br>- <strong>WebAPI</strong> is the entry point. Controllers talk to Application only via interfaces.<br><br><strong>When Should You Use It?</strong><br>Clean Architecture is ideal for:<br>- Mid to large-scale projects<br>- Projects where testability and maintainability are top priorities<br>- Systems that serve multiple clients (web + mobile)<br><br><strong>Drawbacks</strong><br>- Initial setup can feel complex<br>- Might be overkill for small-scale projects<br>- Requires experienced team members<br><br><strong>Conclusion</strong><br>Clean Architecture is one of the strongest architectural approaches in .NET for handling dependencies, testability, and maintainability. It improves on the weaknesses of N-Tier and offers more flexibility than Onion Architecture. When implemented correctly, it provides a long-lasting, robust foundation for your software.<div style='height: 80px;'></div>"
  },
  {
    "id": "4",
    "slug": "mediatr-goes-commercial-jimmy-bogard-decision",
    "title": "MediatR Goes Commercial: Jimmy Bogard’s Decision, Justifications, and Alternatives",
    "summary": "Is MediatR no longer open source? Why did Jimmy Bogard make this decision? What should developers do? All the details are in this article.",
    "description": "As of 2025, the MediatR library has moved to a commercial license. This article explores the reasons behind the decision and its implications for developers.",
    "coverImage": "img/blog/blog4.webp",
    "date": "2025-07-27",
    "content": "MediatR is a library that almost every .NET developer encounters when working with Clean Architecture, CQRS, or Vertical Slice patterns. But in April 2025, a major change was announced: its creator, Jimmy Bogard, declared that MediatR would now be distributed under a commercial license.<br><br><strong>What Happened?</strong><br>In an official blog post, Jimmy Bogard announced that both MediatR and AutoMapper would no longer be released as open source in their future versions. Instead, they will be available under commercial and community licenses. Previous versions will remain under the MIT license and usable, but new features will be introduced only in the new licensed versions.<br><blockquote>“For years, AutoMapper and MediatR were freely available as open source. But maintaining and developing them was never easy.” — Jimmy Bogard</blockquote><br><strong>Why This Decision?</strong><br>While working at Headspring, Jimmy had the time and support to maintain these projects. However, after leaving the company, sponsorships dropped and GitHub support wasn’t enough. Sustainability has always been a challenge in the open source world, and Jimmy clearly voiced this concern:<br><blockquote>“Without GitHub sponsorship or company contributions, I can’t dedicate 20 hours a week to these projects.”</blockquote><br><strong>The New Licensing Model</strong><br>Future versions (starting from MediatR v13) will be distributed under a dual-licensing model:<ul><li><strong>RPL 1.5 (Reciprocal Public License)</strong>: Still open source, but with some limitations.</li><li><strong>Commercial License</strong>: Paid, based on the number of developers in corporate environments.</li></ul>Additionally, a <strong>Community Edition</strong> remains free for individual developers, open source projects, educational purposes, and non-profits.<br><br><strong>Community Response</strong><br>The developer community has generally responded with understanding. Many acknowledge the value MediatR has provided for years. However, some teams have begun exploring alternatives, especially those with limited budgets or seeking lightweight solutions.<br><br><strong>Alternatives</strong><ul><li><strong>Mediator</strong>: A lightweight, source generator–based alternative with high performance.</li><li><strong>Brighter</strong>: A powerful option focused on CQRS and messaging.</li><li><strong>Building Your Own Lightweight Mediator</strong>: A viable solution for simpler projects.</li></ul><br><strong>Why MediatR Matters</strong><br>MediatR is widely used in the .NET ecosystem for:<ul><li>CQRS (Command Query Responsibility Segregation)</li><li>Clean Architecture</li><li>Vertical Slice Architecture</li><li>Pipeline behaviors for logging, validation, caching, etc.</li></ul>It promotes separation of concerns and improves testability by cleanly separating commands and queries. It does so with minimal boilerplate and a very simple API.<br><br><strong>Conclusion</strong><br>MediatR is no longer free, but considering the years of support and value it has provided, this marks a transition in how that value is maintained. Sustainability in open source is becoming a pressing issue, and licensing changes are one of many ways developers are trying to address it. With multiple licensing options now available, developers and teams must evaluate their needs and decide whether to continue using MediatR or switch to an alternative.<div style='height: 80px;'></div>"
  }
]
